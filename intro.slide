Go crash course
27 Mar 2017
Tags: go, tutorial

Will Faught
Senior Software Engineer, BigCommerce
will.faught@bigcommerce.com

* Comments

Two kinds:

    // Line-ending comment

    /* Inter/intra-line comment */

Some comments are special annotations:

    package foo // import "foo.bar"

    // +build tag

    //go:generate command

    // Foo returns the...

* Literals

Untyped:

    123 | 1.2e3 | 123i | 'r' | "s" | false | true | nil

Simple operations are evaluated by the compiler:

    1 + 2 | 3 / 2 | 1 << 2 | 1 < 2 | "a" + "b"

Number literals implicitly type convert:

    var _ complex64 = 123i
    var _ complex128 = 123i
    var _ float32 = 1.2e3
    var _ float64 = 1.2e3
    var _ int8 = 123
    var _ int16 = 123
    var _ int32 = 'r'
    var _ int64 = 'r'

* Literals, continued

Numbers have 256 bits of precision:

    var _ int64 = 1 << 100 // compiler error
    var _ int64 = 1 << 100 >> 100 // no compiler error

Default types:

    var _ = true // bool
    var _ = 7.7i // complex128
    var _ = 7.7 // float64
    var _ = 7 // int
    var _ = nil // compiler error, must be typed
    var _ = 'r' // rune
    var _ = "s" // string

* Built-in named types

* Booleans

Type:

    bool

Literals:

    false | true

Operations:

    && | || | !

    new(bool)

* Integers

Types:

    int | int8 | int16 | int32 | int64 // int is word impl

    uint | uint8 | uint16 | uin32 | uint64 // uint is word impl

    uintptr // word impl

    byte // uint8 impl

    rune // int32 impl

Literals:

    7 | 07 | 0x7 | '7'

* Integers, continued

Operations:

    % | & | `|` | ^ | &^ | << | >>

    %= | &= | `|=` | ^= | &^= | <<= | >>=

    new(int) | new(uint) | new(uintptr) | new(byte) | new(rune)

* Floating points

Types:

    float32 | float64

Literals:

    7 | 07 | 0x7 | '7' | 7.7 | 07.7 | 7e-7

Operations:

    new(float32) | new(float64)

* Complexes

Types:

    complex64 | complex128

Literals:

    7i | 7.7i | 7.7e7i | complex(N1, N1)

Operations:

    new(complex64) | new(complex128)

* Integers, floating points, complexes

Operations:

    + | - | * | /

    += | -= | *= | /=

    == | != | < | <= | > | >=

* Strings

Type:

    string

Literals:

    "" | `` | "s" | `s`

Operations:

    +

    +=

    == | != | < | <= | > | >=

    s[i] | s[i1:i2] | s[i:] | s[:i] | s[:]

    len(s) | new(string) | string([]byte(b))

* Built-in unnamed types

* Arrays

Type:

    [N]T

Literals:

    A{} | A{e} | A{e1, e2} | A{i1: e1, i2: e2}

    [...]T{} | [...]T{e} | [...]T{e1, e2} | [...]T{i1: e1, i2: e2}

Operations:

    == | !=

    a[i] = e | a[i] | a[i1:i2] | a[i:] | a[:i] | a[:]

    cap(a) | len(a) | new(A)

* Slices

Type:

    []T

Literals:

    nil | S{} | S{e} | S{e1, e2} | S{i1: e1, i2: e2, i9: e9}

Operations:

    == nil | != nil

    s[i] = e | s[i] | s[i1:i2] | s[i:] | s[:i] | s[:]

    append(s, e) | append(s, e1, e2) | append(s1, s2...) | copy(dst, src)

    cap(s) | len(s) | make(S) | make(S, c) | make(S, l, c) | new(S)

* Slices, continued

Slices as subarrays:

- Slices are references to subarrays
- Slice indexes start at 0
- Slices have the length of the subarray

Slices as dynamic arrays:

- Appending an element increments the length and inserts it at the last index
- If the last index is outside the array, the subarray is first copied into a bigger array
- Slice capacity is the length from the beginning of the subarray to the end of the array

Slices cannot be compared because they can be circular:

    var s = []interface{}{nil}

    s[0] = s

* Channels

Types:

    chan T | <-chan T | chan<- T

Literal:

    nil

Operations:

    == | !=

    <-c | c <- e | (<-chan T)(c) | (chan<- T)(c)

    cap(c) | close(c) | len(c) | make(C) | make(C, n) | new(C)

* Maps

Type:

    map[T1]T2

Literals:

    nil | M{} | M{i: e} | M{i1: e1, i2: e2}

Operations:

    == nil | != nil

    m[i] = e | m[i]

    len(m) | make(M) | make(M, n) | new(M)

* Pointers

Type:

    *T

Literal:

    nil

Operations:

    == nil | != nil

    &x | *x

* Structs

Types:

    struct{}

    struct{f T} | struct{f1, f2 T} | struct{f1, f2 T; f3, f4 T}

    struct{T} | struct{T1; T2} | struct{T; f T} | struct{T1; f T; T2}

    struct{f T `json:"field_f" xml:"field-f,attr"`} // struct tag namespace format

    struct{f1 T "foo"; f2 T "bar"}

Literals:

    S{} | S{e} | S{e1, e2} | S{f: e} | S{f1: e2, f2: e2}

* Structs, continued

Operations:

    == | !=

    s.f = x | s.f | &s.f

    new(S)

* Functions

Types:

    func() | func(T) | func() T | func(T) T | func(T, T) (T, T)

    func(...T) | func(T, ...T) | func(T, T, ...T)

Literals:

    F{} | F{ /* statements */ }

Operations:

    == nil | != nil

    f() | f(x) | f(x, x) | f(s...) | f(x, s...) | f(x, x, s...)

    new(F)

* Package declarations

* Constants

* Variables

* Functions

* New named types

Declare a new named type in terms of an unnamed type or another named type:

    type newtype oldtype

Named types are convertible to equivalent types

    type T1 int; type T2 int

    var t1 T1 = 7
    var t2 T2 = 8

    t1 = T1(t2) // type conversion of expression t2 to type T1

    var n = int(t2)

* New named types, continued

New named types have the operations of their old counterparts:

    type A [2]int; type F func(); type M map[int]int; type N int; type S []int

    A([2]int{7, 8})[:1]

    F(func(){})()

    M(map[int]int{7: 8})[7]

    N(7) + N(8)

    S("s") + S("t")

* Methods

    type T struct{f T2}

    func (T) m1() {}

    func (t T) m2(T) T { return t }

    func (t *T) m3(T, T) (T, T) { return t, t }

    func (*T) f() {} // compiler error: f is already a field

    var x T1 = ...
    var y *T2 = ...

    x.m1(); (x.m1)()
    y.m1(); (y.m1)()

type T int

func (t *T) negate() {...}

* Interfaces
